{"entries":[{"key":"nte-memberoperator","order":{"section":[0,2,4,5,0,0,0],"number":1},"caption":"Member operator in or ∈"},{"key":"nte-subsetoperator","order":{"section":[0,2,9,5,0,0,0],"number":2},"caption":"Subset operator ⊆"}],"headings":["julia-pros-and-cons","pros","cons","basics","arithmetic-operations-and-number-types","arithmetic-operations","number-types","arithmetic-operations-for-integers","variables","relation-and-logical-operations","relation-operations","logical-operations","control-flow","comment","compound-expressions","short-circuit-evaluation","conditional-evaluation","looping","jump-out-of-loops","functions","inline-functions","multiline-functions","argument-passing-behaviour","specify-the-type-of-return-value","multiple-assignments-and-multiple-return-values","parameter-types","anonymous-functions","do-blocks","the-splat-operator-...","closure","partial-function-application","function-composition-vectorization-and-piping","function-composition","dot-syntax-for-vectorizing-functions","function-piping","exception","metaprogramming","program-representation","expressions-and-evaluation","expressions","evaluation","code-generation","macros","non-standard-string-and-command-literals","generated-functions","types","basics-1","multiple-dispatch","how-does-multiple-dispatch-work","the-way-julia-selects-the-correct-method-of-a-function-for-each-situation","conversion-and-promotion","why-do-we-need-type-promotion","how-does-type-promotion-work","how-does-conversion-work","an-example-extending-the-type-system","defining-unit-types-and-constructors","defining-accessors","displaying-angles","defining-type-conversions","defining-type-promotions","defining-arithmetic-operations","making-pretty-literals-by-using-literal-coefficients","overriding-standard-sin-and-cos-functions-to-only-accept-dms-and-radian","representing-unknown-values","to-solve-infinite-chain-of-initialization-using-parametric-type","collections","strings","unicode-and-utf-8","string-indexing","string-operations","nonstandard-string-literals","arrays","types-of-arrays","creating-arrays-by-specific-functions","accessing-array-attributes","operartions-on-arrays","slicing-and-dicing-an-array","combining-arrays","tuples","named-tuples","dictionaries","creating-a-dictionary","accessing-elements","sets","collection-comprehension","generator","enumerating-values-and-indices","creating-an-enum-type-with-enum-macro","understanding-julia-collections","what-makes-something-a-collection","functional-programming","higher-order-functions","io-networking-and-streams","io-types","stream-io","text-io","io-output-contextual-properties","working-with-files","working-with-networking","tcp-transmission-control-protocol","udp-user-datagram-protocol","parametric-types","defining-parametric-methods","defining-parametric-types","scope-of-variables","introduction","scope-constructs","global-scope","local-scope","let-blocks","loops","constants","typed-globals","parallel-computing","asynchronous-tasks","multi-threading","starting-julia-with-multiple-threads","thread-pools","spawning-threads","avoiding-data-race","multi-processing-and-distributed-computing","starting-and-managing-multiple-processes","starting-distributed-programming","code-and-data-availability","parallel-loops-and-map","noteworthy-external-parallel-packages","running-external-programs","creating-cmd-objects","running-cmd-objects","command-interpolation","quoting","pipelines","julia-documentation-system","modules-and-pakcages","modules","namespace-management","qualified-names","export-lists","using-and-import","how-does-julia-find-a-module","standard-modules","packages","organizing-your-code-into-modules-and-packages","setting-up-your-working-environment","creating-your-own-module-and-package","testing-your-package","appendices","heap-and-stack","julia-installation-and-configuration","julia-repl-mode","installing-third-party-packages"]}